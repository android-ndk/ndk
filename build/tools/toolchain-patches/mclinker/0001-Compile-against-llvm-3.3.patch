From 2de173d78aa32c6663c903be8d90b557061678fa Mon Sep 17 00:00:00 2001
From: Andrew Hsieh <andrewhsieh@google.com>
Date: Thu, 6 Jun 2013 14:12:28 +0800
Subject: [PATCH] Compile against llvm-3.3

Change-Id: Iefc01740017b2710907bf98257a0f68b1551021e
---
 lib/Fragment/FragmentLinker.cpp           |  2 +-
 lib/LD/ELFReader.cpp                      | 44 +++++++++++++++----------------
 lib/LD/GNUArchiveReader.cpp               |  4 +--
 lib/LD/RelocationFactory.cpp              |  2 +-
 tools/llvm-mcld/llvm-mcld.cpp             |  3 ++-
 tools/mcld/lib/Support/Initialization.cpp |  3 ++-
 6 files changed, 30 insertions(+), 28 deletions(-)

diff --git a/lib/Fragment/FragmentLinker.cpp b/lib/Fragment/FragmentLinker.cpp
index 2a183b2..5a4b53f 100644
--- a/lib/Fragment/FragmentLinker.cpp
+++ b/lib/Fragment/FragmentLinker.cpp
@@ -231,7 +231,7 @@ void FragmentLinker::writeRelocationResult(Relocation& pReloc, uint8_t* pOutput)
 
   uint8_t* target_addr = pOutput + out_offset;
   // byte swapping if target and host has different endian, and then write back
-  if(llvm::sys::isLittleEndianHost() != m_Config.targets().isLittleEndian()) {
+  if(llvm::sys::IsLittleEndianHost != m_Config.targets().isLittleEndian()) {
      uint64_t tmp_data = 0;
 
      switch(pReloc.size(*m_Backend.getRelocator())) {
diff --git a/lib/LD/ELFReader.cpp b/lib/LD/ELFReader.cpp
index 6a9d8e4..f7b047f 100644
--- a/lib/LD/ELFReader.cpp
+++ b/lib/LD/ELFReader.cpp
@@ -91,7 +91,7 @@ bool ELFReader<32, true>::readSymbols(Input& pInput,
     st_info  = symtab[idx].st_info;
     st_other = symtab[idx].st_other;
 
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       st_name  = symtab[idx].st_name;
       st_value = symtab[idx].st_value;
       st_size  = symtab[idx].st_size;
@@ -222,7 +222,7 @@ bool ELFReader<32, true>::readRela(Input& pInput,
     uint32_t r_offset = 0x0;
     uint32_t r_info   = 0x0;
     int32_t  r_addend = 0;
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       r_offset = relaTab[idx].r_offset;
       r_info   = relaTab[idx].r_info;
       r_addend = relaTab[idx].r_addend;
@@ -258,7 +258,7 @@ bool ELFReader<32, true>::readRel(Input& pInput,
   for (size_t idx=0; idx < entsize; ++idx) {
     uint32_t r_offset = 0x0;
     uint32_t r_info   = 0x0;
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       r_offset = relTab[idx].r_offset;
       r_info   = relTab[idx].r_info;
     }
@@ -295,7 +295,7 @@ bool ELFReader<32, true>::isMyMachine(void* pELFHeader) const
   llvm::ELF::Elf32_Ehdr* hdr =
                           reinterpret_cast<llvm::ELF::Elf32_Ehdr*>(pELFHeader);
 
-  if (llvm::sys::isLittleEndianHost())
+  if (llvm::sys::IsLittleEndianHost)
     return (hdr->e_machine == target().getInfo().machine());
   return (mcld::bswap16(hdr->e_machine) == target().getInfo().machine());
 }
@@ -306,7 +306,7 @@ Input::Type ELFReader<32, true>::fileType(void* pELFHeader) const
   llvm::ELF::Elf32_Ehdr* hdr =
                           reinterpret_cast<llvm::ELF::Elf32_Ehdr*>(pELFHeader);
   uint32_t type = 0x0;
-  if (llvm::sys::isLittleEndianHost())
+  if (llvm::sys::IsLittleEndianHost)
     type = hdr->e_type;
   else
     type = mcld::bswap16(hdr->e_type);
@@ -338,7 +338,7 @@ ELFReader<32, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
   uint32_t shnum     = 0x0;
   uint32_t shstrtab  = 0x0;
 
-  if (llvm::sys::isLittleEndianHost()) {
+  if (llvm::sys::IsLittleEndianHost) {
     shoff     = ehdr->e_shoff;
     shentsize = ehdr->e_shentsize;
     shnum     = ehdr->e_shnum;
@@ -372,7 +372,7 @@ ELFReader<32, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
                                             shentsize);
     shdr = reinterpret_cast<llvm::ELF::Elf32_Shdr*>(shdr_region->start());
 
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       sh_size = shdr->sh_size;
       sh_link = shdr->sh_link;
     }
@@ -397,7 +397,7 @@ ELFReader<32, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
 
   // get .shstrtab first
   shdr = &shdrTab[shstrtab];
-  if (llvm::sys::isLittleEndianHost()) {
+  if (llvm::sys::IsLittleEndianHost) {
     sh_offset = shdr->sh_offset;
     sh_size   = shdr->sh_size;
   }
@@ -415,7 +415,7 @@ ELFReader<32, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
 
   // create all LDSections, including first NULL section.
   for (size_t idx = 0; idx < shnum; ++idx) {
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       sh_name      = shdrTab[idx].sh_name;
       sh_type      = shdrTab[idx].sh_type;
       sh_flags     = shdrTab[idx].sh_flags;
@@ -495,7 +495,7 @@ ResolveInfo* ELFReader<32, true>::readSignature(Input& pInput,
   uint16_t st_shndx = 0x0;
   st_info  = entry->st_info;
   st_other = entry->st_other;
-  if (llvm::sys::isLittleEndianHost()) {
+  if (llvm::sys::IsLittleEndianHost) {
     st_name  = entry->st_name;
     st_shndx = entry->st_shndx;
   }
@@ -557,7 +557,7 @@ bool ELFReader<32, true>::readDynamic(Input& pInput) const
     llvm::ELF::Elf32_Sword d_tag = 0x0;
     llvm::ELF::Elf32_Word d_val = 0x0;
 
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       d_tag = dynamic[idx].d_tag;
       d_val = dynamic[idx].d_un.d_val;
     } else {
@@ -652,7 +652,7 @@ bool ELFReader<64, true>::readSymbols(Input& pInput,
     st_info  = symtab[idx].st_info;
     st_other = symtab[idx].st_other;
 
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       st_name  = symtab[idx].st_name;
       st_value = symtab[idx].st_value;
       st_size  = symtab[idx].st_size;
@@ -778,7 +778,7 @@ bool ELFReader<64, true>::readRela(Input& pInput,
     uint64_t r_offset = 0x0;
     uint64_t r_info   = 0x0;
     int64_t  r_addend = 0;
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       r_offset = relaTab[idx].r_offset;
       r_info   = relaTab[idx].r_info;
       r_addend = relaTab[idx].r_addend;
@@ -814,7 +814,7 @@ bool ELFReader<64, true>::readRel(Input& pInput,
   for (size_t idx=0; idx < entsize; ++idx) {
     uint64_t r_offset = 0x0;
     uint64_t r_info   = 0x0;
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       r_offset = relTab[idx].r_offset;
       r_info   = relTab[idx].r_info;
     }
@@ -851,7 +851,7 @@ bool ELFReader<64, true>::isMyMachine(void* pELFHeader) const
   llvm::ELF::Elf64_Ehdr* hdr =
                           reinterpret_cast<llvm::ELF::Elf64_Ehdr*>(pELFHeader);
 
-  if (llvm::sys::isLittleEndianHost())
+  if (llvm::sys::IsLittleEndianHost)
     return (hdr->e_machine == target().getInfo().machine());
   return (mcld::bswap16(hdr->e_machine) == target().getInfo().machine());
 }
@@ -862,7 +862,7 @@ Input::Type ELFReader<64, true>::fileType(void* pELFHeader) const
   llvm::ELF::Elf64_Ehdr* hdr =
                           reinterpret_cast<llvm::ELF::Elf64_Ehdr*>(pELFHeader);
   uint32_t type = 0x0;
-  if (llvm::sys::isLittleEndianHost())
+  if (llvm::sys::IsLittleEndianHost)
     type = hdr->e_type;
   else
     type = mcld::bswap16(hdr->e_type);
@@ -894,7 +894,7 @@ ELFReader<64, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
   uint32_t shnum     = 0x0;
   uint32_t shstrtab  = 0x0;
 
-  if (llvm::sys::isLittleEndianHost()) {
+  if (llvm::sys::IsLittleEndianHost) {
     shoff     = ehdr->e_shoff;
     shentsize = ehdr->e_shentsize;
     shnum     = ehdr->e_shnum;
@@ -928,7 +928,7 @@ ELFReader<64, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
                                             shentsize);
     shdr = reinterpret_cast<llvm::ELF::Elf64_Shdr*>(shdr_region->start());
 
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       sh_size = shdr->sh_size;
       sh_link = shdr->sh_link;
     }
@@ -953,7 +953,7 @@ ELFReader<64, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
 
   // get .shstrtab first
   shdr = &shdrTab[shstrtab];
-  if (llvm::sys::isLittleEndianHost()) {
+  if (llvm::sys::IsLittleEndianHost) {
     sh_offset = shdr->sh_offset;
     sh_size   = shdr->sh_size;
   }
@@ -971,7 +971,7 @@ ELFReader<64, true>::readSectionHeaders(Input& pInput, void* pELFHeader) const
 
   // create all LDSections, including first NULL section.
   for (size_t idx = 0; idx < shnum; ++idx) {
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       sh_name      = shdrTab[idx].sh_name;
       sh_type      = shdrTab[idx].sh_type;
       sh_flags     = shdrTab[idx].sh_flags;
@@ -1051,7 +1051,7 @@ ResolveInfo* ELFReader<64, true>::readSignature(Input& pInput,
   uint16_t st_shndx = 0x0;
   st_info  = entry->st_info;
   st_other = entry->st_other;
-  if (llvm::sys::isLittleEndianHost()) {
+  if (llvm::sys::IsLittleEndianHost) {
     st_name  = entry->st_name;
     st_shndx = entry->st_shndx;
   }
@@ -1113,7 +1113,7 @@ bool ELFReader<64, true>::readDynamic(Input& pInput) const
     llvm::ELF::Elf64_Sxword d_tag = 0x0;
     llvm::ELF::Elf64_Xword d_val = 0x0;
 
-    if (llvm::sys::isLittleEndianHost()) {
+    if (llvm::sys::IsLittleEndianHost) {
       d_tag = dynamic[idx].d_tag;
       d_val = dynamic[idx].d_un.d_val;
     } else {
diff --git a/lib/LD/GNUArchiveReader.cpp b/lib/LD/GNUArchiveReader.cpp
index 6324824..e391b20 100644
--- a/lib/LD/GNUArchiveReader.cpp
+++ b/lib/LD/GNUArchiveReader.cpp
@@ -265,7 +265,7 @@ bool GNUArchiveReader::readSymbolTable(Archive& pArchive)
 
     // read the number of symbols
     uint32_t number = 0;
-    if (llvm::sys::isLittleEndianHost())
+    if (llvm::sys::IsLittleEndianHost)
       number = mcld::bswap32(*data);
     else
       number = *data;
@@ -276,7 +276,7 @@ bool GNUArchiveReader::readSymbolTable(Archive& pArchive)
 
     // add the archive symbols
     for (uint32_t i = 0; i < number; ++i) {
-      if (llvm::sys::isLittleEndianHost())
+      if (llvm::sys::IsLittleEndianHost)
         pArchive.addSymbol(name, mcld::bswap32(*data));
       else
         pArchive.addSymbol(name, *data);
diff --git a/lib/LD/RelocationFactory.cpp b/lib/LD/RelocationFactory.cpp
index 8a065a8..bb56cdd 100644
--- a/lib/LD/RelocationFactory.cpp
+++ b/lib/LD/RelocationFactory.cpp
@@ -45,7 +45,7 @@ Relocation* RelocationFactory::produce(RelocationFactory::Type pType,
   DWord target_data = 0;
 
   // byte swapping if the host and target have different endian
-  if(llvm::sys::isLittleEndianHost() != m_pConfig->targets().isLittleEndian()) {
+  if(llvm::sys::IsLittleEndianHost != m_pConfig->targets().isLittleEndian()) {
      uint32_t tmp_data;
 
      switch (m_pConfig->targets().bitclass()) {
diff --git a/tools/llvm-mcld/llvm-mcld.cpp b/tools/llvm-mcld/llvm-mcld.cpp
index e984501..27585b1 100644
--- a/tools/llvm-mcld/llvm-mcld.cpp
+++ b/tools/llvm-mcld/llvm-mcld.cpp
@@ -36,13 +36,14 @@
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/FormattedStream.h>
 #include <llvm/Support/Host.h>
-#include <llvm/Support/IRReader.h>
+#include <llvm/IRReader/IRReader.h>
 #include <llvm/Support/ManagedStatic.h>
 #include <llvm/Support/Signals.h>
 #include <llvm/Support/TargetRegistry.h>
 #include <llvm/Support/TargetSelect.h>
 #include <llvm/Support/Process.h>
 #include <llvm/Target/TargetMachine.h>
+#include <llvm/Support/SourceMgr.h>
 
 #if defined(HAVE_UNISTD_H)
 # include <unistd.h>
diff --git a/tools/mcld/lib/Support/Initialization.cpp b/tools/mcld/lib/Support/Initialization.cpp
index 71bd57d..90cb574 100644
--- a/tools/mcld/lib/Support/Initialization.cpp
+++ b/tools/mcld/lib/Support/Initialization.cpp
@@ -22,7 +22,8 @@
 
 namespace {
 
-void llvm_error_handler(void *pUserData, const std::string &pMessage) {
+void llvm_error_handler(void *pUserData, const std::string &pMessage,
+                        bool gen_crash_diag = true) {
   ALOGE("%s", pMessage.c_str());
   ::exit(1);
 }
-- 
1.8.3

